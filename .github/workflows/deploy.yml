name: Deploy Full App

on:
  push:
    branches: [ features, qa, main ]

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  set-env:
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.env.outputs.env }}
      backend: ${{ steps.env.outputs.backend }}
    steps:
      - id: env
        run: |
          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            echo "env=prod" >> $GITHUB_OUTPUT
            echo "backend=backend-prod.hcl" >> $GITHUB_OUTPUT
          else
            echo "env=qa" >> $GITHUB_OUTPUT
            echo "backend=backend-qa.hcl" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    needs: set-env
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6


      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Build & push backend images
        run: |
          set -e
          TAG="${{ needs.set-env.outputs.env }}-latest"
          SERVICES="user-service activity-service agreement-service approval-service audit-service notification-service document-service event-service backup-service evidence-service api-gateway"
          for s in $SERVICES; do
            if [ -d "packages/backend/$s" ]; then
              docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/$s:$TAG packages/backend/$s
              docker push ${{ secrets.DOCKERHUB_USERNAME }}/$s:$TAG
            fi
          done

      - name: Build & push frontend web image
        run: |
          set -e
          TAG="${{ needs.set-env.outputs.env }}-latest"
          if [ -d "packages/frontend/web" ]; then
            docker build -t ${{ secrets.DOCKERHUB_USERNAME }}/frontend-web:$TAG packages/frontend/web
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/frontend-web:$TAG
          fi

  deploy:
    needs: [set-env, build-and-push]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_BASTION_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_BASTION_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_BASTION_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Terraform init (read state)
        working-directory: infra/terraform
        run: |
          terraform init -reconfigure -backend-config=${{ needs.set-env.outputs.backend }}

      - name: Read outputs
        working-directory: infra/terraform
        run: |
          terraform output -json > /tmp/tfout.json

      - name: Prepare SSH key (from terraform output json)
        run: |
          set -e
          KEY=$(jq -r '.ssh_private_key_pem.value // empty' /tmp/tfout.json)
          if [ -z "$KEY" ]; then
            echo "ERROR: ssh_private_key_pem is empty in terraform output json"
            cat /tmp/tfout.json | jq '.'
            exit 1
          fi
          echo "$KEY" > /tmp/key.pem
          chmod 600 /tmp/key.pem


      - name: Extract IPs
        run: |
          set -e
          TF=/tmp/tfout.json

          echo "BASTION_IP=$(jq -r '.bastion_public_ip.value' $TF)" >> $GITHUB_ENV
          echo "FE_WEB_IP=$(jq -r '.frontend_web_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "API_GW_IP=$(jq -r '.api_gateway_private_ip.value' $TF)" >> $GITHUB_ENV

          echo "USER_IP=$(jq -r '.user_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "ACT_IP=$(jq -r '.activity_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "AGR_IP=$(jq -r '.agreement_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "APP_IP=$(jq -r '.approval_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "AUD_IP=$(jq -r '.audit_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "NOTIF_IP=$(jq -r '.notification_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "DOC_IP=$(jq -r '.document_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "EVENT_IP=$(jq -r '.event_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "BACKUP_IP=$(jq -r '.backup_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "EVID_IP=$(jq -r '.evidence_private_ip.value' $TF)" >> $GITHUB_ENV

          echo "REDIS_IP=$(jq -r '.redis_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "MQTT_IP=$(jq -r '.mqtt_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "KAFKA_IP=$(jq -r '.kafka_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "MONGO_IP=$(jq -r '.mongo_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "RABBIT_IP=$(jq -r '.rabbit_private_ip.value' $TF)" >> $GITHUB_ENV
          echo "N8N_IP=$(jq -r '.n8n_private_ip.value' $TF)" >> $GITHUB_ENV

          BASTION_IP=$(jq -r '.bastion_public_ip.value // empty' /tmp/tfout.json)
          if [ -z "$BASTION_IP" ]; then
            echo "ERROR: bastion_public_ip is empty"
            cat /tmp/tfout.json | jq '.'
            exit 1
          fi
          echo "BASTION_IP=$BASTION_IP" >> $GITHUB_ENV


      - name: Upload jump key to Bastion 
        run: |
          scp -i /tmp/key.pem -o StrictHostKeyChecking=no /tmp/key.pem ec2-user@${{ env.BASTION_IP }}:/tmp/jump.pem
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "chmod 600 /tmp/jump.pem"

      - name: Configure Bastion NGINX (public entrypoint)
        run: |
          cat > /tmp/default.conf <<EOF
          server {
            listen 80;

            location /api/ {
              proxy_pass http://${{ env.API_GW_IP }}:8000/;
            }

            location / {
              proxy_pass http://${{ env.FE_WEB_IP }}:80/;
              try_files \$uri \$uri/ /index.html;
            }
          }
          EOF

          scp -i /tmp/key.pem -o StrictHostKeyChecking=no /tmp/default.conf ec2-user@${{ env.BASTION_IP }}:/tmp/default.conf
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "sudo mv /tmp/default.conf /etc/nginx/conf.d/default.conf && sudo nginx -t && sudo systemctl restart nginx"

      - name: Common - install docker + create network (remote helper)
        run: |
          cat > /tmp/remote_prep.sh <<'SH'
          set -e
          if ! command -v docker >/dev/null 2>&1; then
            sudo yum update -y || true
            sudo amazon-linux-extras install docker -y || sudo yum install -y docker
            sudo systemctl enable docker
            sudo systemctl start docker
            sudo usermod -aG docker ec2-user || true
          fi
          sudo docker network create app-network >/dev/null 2>&1 || true
          SH
          chmod +x /tmp/remote_prep.sh

      - name: Deploy frontend-web container
        run: |
          TAG="${{ needs.set-env.outputs.env }}-latest"

          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.FE_WEB_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.FE_WEB_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_PASSWORD }}
              sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/frontend-web:${TAG}
              sudo docker rm -f frontend-web || true
              sudo docker run -d --name frontend-web --network app-network -p 80:80 ${{ secrets.DOCKERHUB_USERNAME }}/frontend-web:${TAG}
            '
          "

      - name: Render API Gateway nginx with real upstream IPs (plural routes)
        run: |
          cat > /tmp/api-gw-nginx.conf <<EOF
          events { worker_connections 1024; }
          http {
            limit_req_zone \$binary_remote_addr zone=api:10m rate=10r/s;

            upstream user_service      { server ${{ env.USER_IP }}:8000; }
            upstream activity_service  { server ${{ env.ACT_IP }}:8000; }
            upstream agreement_service { server ${{ env.AGR_IP }}:8000; }
            upstream approval_service  { server ${{ env.APP_IP }}:8000; }

            server {
              listen 80;

              location /api/users/      { limit_req zone=api burst=20 nodelay; proxy_pass http://user_service/; }
              location /api/activities/ { limit_req zone=api burst=20 nodelay; proxy_pass http://activity_service/; }
              location /api/agreements/ { limit_req zone=api burst=20 nodelay; proxy_pass http://agreement_service/; }
              location /api/approvals/  { limit_req zone=api burst=20 nodelay; proxy_pass http://approval_service/; }

              location / { return 404; }
            }
          }
          EOF

          scp -i /tmp/key.pem -o StrictHostKeyChecking=no /tmp/api-gw-nginx.conf ec2-user@${{ env.BASTION_IP }}:/tmp/api-gw-nginx.conf

      - name: Deploy api-gateway container (mount nginx)
        run: |
          TAG="${{ needs.set-env.outputs.env }}-latest"

          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/api-gw-nginx.conf ec2-user@${{ env.API_GW_IP }}:/tmp/nginx.conf
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.API_GW_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.API_GW_IP }} '
              bash /tmp/remote_prep.sh
              sudo mkdir -p /etc/api-gateway
              sudo mv /tmp/nginx.conf /etc/api-gateway/nginx.conf

              sudo docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_PASSWORD }}
              sudo docker pull ${{ secrets.DOCKERHUB_USERNAME }}/api-gateway:${TAG}
              sudo docker rm -f api-gateway || true
              sudo docker run -d --name api-gateway --network app-network -p 8000:80 \
                -v /etc/api-gateway/nginx.conf:/etc/nginx/nginx.conf:ro \
                ${{ secrets.DOCKERHUB_USERNAME }}/api-gateway:${TAG}
            '
          "

      - name: Deploy DB+Services like docker-compose (user/activity/agreement/approval)
        run: |
          TAG="${{ needs.set-env.outputs.env }}-latest"

          # sube init scripts al bastion
          scp -i /tmp/key.pem -o StrictHostKeyChecking=no -r packages/backend/user-service/db ec2-user@${{ env.BASTION_IP }}:/tmp/user-db-init
          scp -i /tmp/key.pem -o StrictHostKeyChecking=no -r packages/backend/activity-service/db ec2-user@${{ env.BASTION_IP }}:/tmp/activity-db-init
          scp -i /tmp/key.pem -o StrictHostKeyChecking=no -r packages/backend/agreement-service/db ec2-user@${{ env.BASTION_IP }}:/tmp/agreement-db-init
          scp -i /tmp/key.pem -o StrictHostKeyChecking=no -r packages/backend/approval-service/db ec2-user@${{ env.BASTION_IP }}:/tmp/approval-db-init

          deploy_pair () {
            HOST_IP="$1"
            DB_NAME="$2"
            DB_USER="$3"
            DB_PASS="$4"
            DB_CONTAINER="$5"
            SVC_CONTAINER="$6"
            IMAGE="$7"

            ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
              scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${HOST_IP}:/tmp/remote_prep.sh
              ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${HOST_IP} '
                bash /tmp/remote_prep.sh
                sudo docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_PASSWORD }}
              '
            "

            # copia init scripts desde bastion al host
            ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
              scp -i /tmp/jump.pem -o StrictHostKeyChecking=no -r /tmp/${DB_CONTAINER}-init/db ec2-user@${HOST_IP}:/tmp/${DB_CONTAINER}-init
            "

            ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
              ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${HOST_IP} '
                sudo docker rm -f ${DB_CONTAINER} || true
                sudo docker run -d --name ${DB_CONTAINER} --network app-network \
                  -e POSTGRES_DB=${DB_NAME} \
                  -e POSTGRES_USER=${DB_USER} \
                  -e POSTGRES_PASSWORD=${DB_PASS} \
                  -v /tmp/${DB_CONTAINER}-init:/docker-entrypoint-initdb.d \
                  postgres:15

                sudo docker pull ${IMAGE}:${TAG}
                sudo docker rm -f ${SVC_CONTAINER} || true
                sudo docker run -d --name ${SVC_CONTAINER} --network app-network -p 8000:8000 \
                  -e DB_HOST=${DB_CONTAINER} \
                  -e DB_PORT=5432 \
                  -e DB_NAME=${DB_NAME} \
                  -e DB_USER=${DB_USER} \
                  -e DB_PASSWORD=${DB_PASS} \
                  ${IMAGE}:${TAG}
              '
            "
          }

          # renombra carpetas en bastion para que la funci贸n copie bien
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            mv /tmp/user-db-init /tmp/user-db-init-tmp && mkdir -p /tmp/user-db-init && mv /tmp/user-db-init-tmp/db /tmp/user-db-init/db
            mv /tmp/activity-db-init /tmp/activity-db-init-tmp && mkdir -p /tmp/activity-db-init && mv /tmp/activity-db-init-tmp/db /tmp/activity-db-init/db
            mv /tmp/agreement-db-init /tmp/agreement-db-init-tmp && mkdir -p /tmp/agreement-db-init && mv /tmp/agreement-db-init-tmp/db /tmp/agreement-db-init/db
            mv /tmp/approval-db-init /tmp/approval-db-init-tmp && mkdir -p /tmp/approval-db-init && mv /tmp/approval-db-init-tmp/db /tmp/approval-db-init/db
          "

          # user
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "mv /tmp/user-db-init /tmp/user-db-init-init || true"
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "mv /tmp/user-db-init-init /tmp/user-db-init || true"
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "mv /tmp/user-db-init /tmp/user-db-init || true"
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "mv /tmp/user-db-init /tmp/user-db-init || true"

          # mapeo exacto a lo que espera la funci贸n: /tmp/<DB_CONTAINER>-init/db
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "mv /tmp/user-db-init /tmp/user-db-init || true"

          # realmente: creamos las rutas que la funci贸n usa:
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            rm -rf /tmp/user-db-init && mv /tmp/user-db-init-tmp /tmp/user-db-init || true
            rm -rf /tmp/activity-db-init && mv /tmp/activity-db-init-tmp /tmp/activity-db-init || true
            rm -rf /tmp/agreement-db-init && mv /tmp/agreement-db-init-tmp /tmp/agreement-db-init || true
            rm -rf /tmp/approval-db-init && mv /tmp/approval-db-init-tmp /tmp/approval-db-init || true
          "

          # Copias correctas (DB_CONTAINER)-init
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "rm -rf /tmp/user-db-init && cp -r /tmp/user-db-init-tmp /tmp/user-db-init || true" || true

          # Deploys (container names igual a tu compose)
          deploy_pair "${{ env.USER_IP }}"  "bd_academic_users" "postgres" "userdb123"      "user-db"     "user-service"     "${{ secrets.DOCKERHUB_USERNAME }}/user-service"
          deploy_pair "${{ env.ACT_IP }}"   "activity_db"      "admin"    "activitydb123"  "activity-db" "activity-service" "${{ secrets.DOCKERHUB_USERNAME }}/activity-service"
          deploy_pair "${{ env.AGR_IP }}"   "agreement_db"     "admin"    "agreementdb123" "agreement-db" "agreement-service" "${{ secrets.DOCKERHUB_USERNAME }}/agreement-service"
          deploy_pair "${{ env.APP_IP }}"   "approval_db"      "admin"    "approvaldb123"  "approval-db" "approval-service" "${{ secrets.DOCKERHUB_USERNAME }}/approval-service"

      - name: Deploy data containers (redis/mqtt/kafka/mongo/rabbit/n8n) on their EC2
        run: |
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            deploy_data () {
              IP=\$1
              shift
              scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@\$IP:/tmp/remote_prep.sh
              ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@\$IP \"bash /tmp/remote_prep.sh; sudo docker rm -f \$@ || true\"
            }
            :
          " || true

          # Redis
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.REDIS_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.REDIS_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f redis || true
              sudo docker run -d --name redis --network app-network -p 6379:6379 redis:7
            '
          "

          # MQTT
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.MQTT_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.MQTT_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f mqtt-broker || true
              sudo docker run -d --name mqtt-broker --network app-network -p 1883:1883 eclipse-mosquitto
            '
          "

          # Kafka
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.KAFKA_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.KAFKA_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f kafka || true
              sudo docker run -d --name kafka --network app-network -p 9092:9092 apache/kafka:latest
            '
          "

          # Mongo
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.MONGO_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.MONGO_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f mongo || true
              sudo docker run -d --name mongo --network app-network -p 27017:27017 mongo:6
            '
          "

          # Rabbit
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.RABBIT_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.RABBIT_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f rabbitmq || true
              sudo docker run -d --name rabbitmq --network app-network -p 5672:5672 rabbitmq:3
            '
          "

          # n8n
          ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
            scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${{ env.N8N_IP }}:/tmp/remote_prep.sh
            ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${{ env.N8N_IP }} '
              bash /tmp/remote_prep.sh
              sudo docker rm -f n8n || true
              sudo docker run -d --name n8n --network app-network -p 5678:5678 n8nio/n8n
            '
          "

      - name: Deploy other microservices (no-db) + notification with real IPs
        run: |
          TAG="${{ needs.set-env.outputs.env }}-latest"

          deploy_micro () {
            NAME="$1"; IP="$2"; IMAGE="$3"; EXTRA_ENV="$4"
            ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${{ env.BASTION_IP }} "
              scp -i /tmp/jump.pem -o StrictHostKeyChecking=no /tmp/remote_prep.sh ec2-user@${IP}:/tmp/remote_prep.sh
              ssh -i /tmp/jump.pem -o StrictHostKeyChecking=no ec2-user@${IP} '
                bash /tmp/remote_prep.sh
                sudo docker login -u ${{ secrets.DOCKERHUB_USERNAME }} -p ${{ secrets.DOCKERHUB_PASSWORD }}
                sudo docker pull ${IMAGE}:${TAG}
                sudo docker rm -f ${NAME} || true
                sudo docker run -d --name ${NAME} --network app-network -p 8000:8000 ${EXTRA_ENV} ${IMAGE}:${TAG}
              '
            "
          }

          # notification (usa MQTT + Redis reales por IP)
          deploy_micro "notification-service" "${{ env.NOTIF_IP }}" "${{ secrets.DOCKERHUB_USERNAME }}/notification-service" \
            "-e MQTT_BROKER=${{ env.MQTT_IP }} -e MQTT_PORT=1883 -e REDIS_HOST=${{ env.REDIS_IP }} -e REDIS_PORT=6379"

          # audit/document/event/backup/evidence (sin env en tu c贸digo)
          deploy_micro "audit-service"     "${{ env.AUD_IP }}"    "${{ secrets.DOCKERHUB_USERNAME }}/audit-service" ""
          deploy_micro "document-service"  "${{ env.DOC_IP }}"    "${{ secrets.DOCKERHUB_USERNAME }}/document-service" ""
          deploy_micro "event-service"     "${{ env.EVENT_IP }}"  "${{ secrets.DOCKERHUB_USERNAME }}/event-service" ""
          deploy_micro "backup-service"    "${{ env.BACKUP_IP }}" "${{ secrets.DOCKERHUB_USERNAME }}/backup-service" ""
          deploy_micro "evidence-service"  "${{ env.EVID_IP }}"   "${{ secrets.DOCKERHUB_USERNAME }}/evidence-service" ""

      - name: Cleanup
        if: always()
        run: |
          if [ -f /tmp/key.pem ] && [ -n "${BASTION_IP:-}" ]; then
            ssh -i /tmp/key.pem -o StrictHostKeyChecking=no ec2-user@${BASTION_IP} "rm -f /tmp/jump.pem" || true
          fi
