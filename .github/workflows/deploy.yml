name: CD Deploy (only changed services)

on:
  workflow_call:
    inputs:
      tag:
        required: true
        type: string
      env_alias:
        required: true
        type: string
      services:
        required: true
        type: string

concurrency:
  group: cd-${{ inputs.env_alias }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set TF backend/vars from env_alias
        run: |
          echo "TAG=${{ inputs.tag }}" >> $GITHUB_ENV
          echo "ENV_ALIAS=${{ inputs.env_alias }}" >> $GITHUB_ENV
          echo "SERVICES=${{ inputs.services }}" >> $GITHUB_ENV

          if [ "${{ inputs.env_alias }}" = "prod" ]; then
            echo "TF_BACKEND=backend-prod.hcl" >> $GITHUB_ENV
            echo "TFVARS=prod.tfvars" >> $GITHUB_ENV
          else
            echo "TF_BACKEND=backend-qa.hcl" >> $GITHUB_ENV
            echo "TFVARS=qa.tfvars" >> $GITHUB_ENV
          fi

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Configure AWS creds (bastion account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_BASTION_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_BASTION_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_BASTION_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Terraform init (read outputs)
        run: terraform -chdir=infra/terraform init -reconfigure -backend-config=$TF_BACKEND

      - name: Get bastion public ip
        id: bastion
        run: |
          echo "HOST=$(terraform -chdir=infra/terraform output -raw bastion_public_ip)" >> $GITHUB_OUTPUT

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY_QA }}" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
      - name: Show SSH key fingerprint used by runner
        run: |
          echo "=== Runner key fingerprint (from SSH_PRIVATE_KEY_QA) ==="
          ssh-keygen -y -f ~/.ssh/id_rsa > /tmp/runner.pub
          ssh-keygen -lf /tmp/runner.pub
    

      - name: Push public key to bastion (EC2 Instance Connect)
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=*bastion*" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" --output text)

          AZ=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query "Reservations[0].Instances[0].Placement.AvailabilityZone" --output text)

          aws ec2-instance-connect send-ssh-public-key \
            --instance-id "$INSTANCE_ID" \
            --availability-zone "$AZ" \
            --instance-os-user ec2-user \
            --ssh-public-key "${{ secrets.SSH_PUBLIC_KEY_QA }}"

      - name: Test SSH to bastion
        env:
          BASTION_HOST: ${{ steps.bastion.outputs.HOST }}
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -o IdentitiesOnly=yes ec2-user@"$BASTION_HOST" "whoami && hostname"




      - name: Verify key_name in Terraform state (user-service)
        run: |
          terraform -chdir=infra/terraform init -reconfigure -backend-config=$TF_BACKEND
          echo "=== key_name in state for ms_user_service ==="
          terraform -chdir=infra/terraform state show module.ms_user_service.aws_instance.microservice[0] | sed -n '1,120p' | grep -E "key_name|ami|subnet_id|private_ip|tags"

      - name: Push public key to target instances (EIC + read state with bastion creds)
        env:
          # bastion creds (for reading terraform remote state in S3)
          AWS_BASTION_ACCESS_KEY_ID: ${{ secrets.AWS_BASTION_ACCESS_KEY_ID }}
          AWS_BASTION_SECRET_ACCESS_KEY: ${{ secrets.AWS_BASTION_SECRET_ACCESS_KEY }}
          AWS_BASTION_SESSION_TOKEN: ${{ secrets.AWS_BASTION_SESSION_TOKEN }}

          # Frontend account
          AWS_FRONTEND_ACCESS_KEY_ID: ${{ secrets.AWS_FRONTEND_ACCESS_KEY_ID }}
          AWS_FRONTEND_SECRET_ACCESS_KEY: ${{ secrets.AWS_FRONTEND_SECRET_ACCESS_KEY }}
          AWS_FRONTEND_SESSION_TOKEN: ${{ secrets.AWS_FRONTEND_SESSION_TOKEN }}

          # Databases account
          AWS_DATABASES_ACCESS_KEY_ID: ${{ secrets.AWS_DATABASES_ACCESS_KEY_ID }}
          AWS_DATABASES_SECRET_ACCESS_KEY: ${{ secrets.AWS_DATABASES_SECRET_ACCESS_KEY }}
          AWS_DATABASES_SESSION_TOKEN: ${{ secrets.AWS_DATABASES_SESSION_TOKEN }}

          # Microservices A account
          AWS_MS_A_ACCESS_KEY_ID: ${{ secrets.AWS_MS_A_ACCESS_KEY_ID }}
          AWS_MS_A_SECRET_ACCESS_KEY: ${{ secrets.AWS_MS_A_SECRET_ACCESS_KEY }}
          AWS_MS_A_SESSION_TOKEN: ${{ secrets.AWS_MS_A_SESSION_TOKEN }}

          # Microservices B account
          AWS_MS_B_ACCESS_KEY_ID: ${{ secrets.AWS_MS_B_ACCESS_KEY_ID }}
          AWS_MS_B_SECRET_ACCESS_KEY: ${{ secrets.AWS_MS_B_SECRET_ACCESS_KEY }}
          AWS_MS_B_SESSION_TOKEN: ${{ secrets.AWS_MS_B_SESSION_TOKEN }}

          SSH_PUBLIC_KEY_QA: ${{ secrets.SSH_PUBLIC_KEY_QA }}
        run: |
          set -e

          # --- Force Terraform to use BASTION creds (S3 state access) ---
          export AWS_ACCESS_KEY_ID="$AWS_BASTION_ACCESS_KEY_ID"
          export AWS_SECRET_ACCESS_KEY="$AWS_BASTION_SECRET_ACCESS_KEY"
          export AWS_SESSION_TOKEN="$AWS_BASTION_SESSION_TOKEN"
          export AWS_REGION=us-east-1
          export AWS_DEFAULT_REGION=us-east-1

          terraform -chdir=infra/terraform init -reconfigure -backend-config=$TF_BACKEND
          ENDPOINTS_JSON=$(terraform -chdir=infra/terraform output -json service_endpoints)

          for SVC in $SERVICES; do
            IP=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('$SVC', {}).get('ip'))")
            echo "Service=$SVC IP=$IP"

            # --- Get INSTANCE_ID + AZ from terraform state while still on BASTION creds ---
            SVC_TF=$(echo "$SVC" | tr '-' '_')
            ADDR=$(terraform -chdir=infra/terraform state list | grep -E "^module\.ms_${SVC_TF}\.aws_instance\.microservice\[0\]$" | head -n 1)

            if [ -z "$ADDR" ]; then
              echo "ERROR: Could not find instance state address for service=$SVC"
              terraform -chdir=infra/terraform state list | grep -E "module\.ms_${SVC_TF}\." || true
              exit 1
            fi

            INSTANCE_ID=$(terraform -chdir=infra/terraform state show -no-color "$ADDR" | awk -F' = ' '/^[[:space:]]*id[[:space:]]*=/{gsub(/"/,"",$2); print $2; exit}')
            AZ=$(terraform -chdir=infra/terraform state show -no-color "$ADDR" | awk -F' = ' '/^[[:space:]]*availability_zone[[:space:]]*=/{gsub(/"/,"",$2); print $2; exit}')

            if [ -z "$INSTANCE_ID" ] || [ -z "$AZ" ]; then
              echo "ERROR: Failed to extract INSTANCE_ID/AZ from terraform state ($ADDR)"
              exit 1
            fi

            # --- NOW switch AWS creds ONLY for EC2 Instance Connect call ---
            if echo "$IP" | grep -qE '^10\.20\.'; then
              export AWS_ACCESS_KEY_ID="$AWS_MS_A_ACCESS_KEY_ID"
              export AWS_SECRET_ACCESS_KEY="$AWS_MS_A_SECRET_ACCESS_KEY"
              export AWS_SESSION_TOKEN="$AWS_MS_A_SESSION_TOKEN"
              echo "Using account: MS_A"
            elif echo "$IP" | grep -qE '^10\.30\.'; then
              export AWS_ACCESS_KEY_ID="$AWS_MS_B_ACCESS_KEY_ID"
              export AWS_SECRET_ACCESS_KEY="$AWS_MS_B_SECRET_ACCESS_KEY"
              export AWS_SESSION_TOKEN="$AWS_MS_B_SESSION_TOKEN"
              echo "Using account: MS_B"
            elif echo "$IP" | grep -qE '^10\.10\.'; then
              export AWS_ACCESS_KEY_ID="$AWS_FRONTEND_ACCESS_KEY_ID"
              export AWS_SECRET_ACCESS_KEY="$AWS_FRONTEND_SECRET_ACCESS_KEY"
              export AWS_SESSION_TOKEN="$AWS_FRONTEND_SESSION_TOKEN"
              echo "Using account: FRONTEND"
            elif echo "$IP" | grep -qE '^10\.40\.'; then
              export AWS_ACCESS_KEY_ID="$AWS_DATABASES_ACCESS_KEY_ID"
              export AWS_SECRET_ACCESS_KEY="$AWS_DATABASES_SECRET_ACCESS_KEY"
              export AWS_SESSION_TOKEN="$AWS_DATABASES_SESSION_TOKEN"
              echo "Using account: DATABASES"
            else
              echo "ERROR: Unknown IP range for $SVC: $IP"
              exit 1
            fi

            export AWS_REGION=us-east-1
            export AWS_DEFAULT_REGION=us-east-1

            echo "Pushing SSH key to $SVC -> $INSTANCE_ID in $AZ"
            aws ec2-instance-connect send-ssh-public-key \
              --instance-id "$INSTANCE_ID" \
              --availability-zone "$AZ" \
              --instance-os-user ec2-user \
              --ssh-public-key "$SSH_PUBLIC_KEY_QA"

            # --- switch back to BASTION creds for next terraform state read ---
            export AWS_ACCESS_KEY_ID="$AWS_BASTION_ACCESS_KEY_ID"
            export AWS_SECRET_ACCESS_KEY="$AWS_BASTION_SECRET_ACCESS_KEY"
            export AWS_SESSION_TOKEN="$AWS_BASTION_SESSION_TOKEN"
          done



      - name: Deploy changed services 
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
          BASTION_HOST: ${{ steps.bastion.outputs.HOST }}
        run: |
          ENDPOINTS_JSON=$(terraform -chdir=infra/terraform output -json service_endpoints)

          
          TARGET_USER="ec2-user"

          for SVC in $SERVICES; do
            IP=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['$SVC']['ip'])")
            PORT=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['$SVC']['port'])")

            IMAGE="${DOCKERHUB_USERNAME}/${SVC}:${TAG}"

            ssh -i ~/.ssh/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
              -J ec2-user@"$BASTION_HOST" "$TARGET_USER@$IP" <<EOF
          set -e
          if ! command -v docker >/dev/null 2>&1; then
            sudo yum -y update || true
            sudo amazon-linux-extras install -y docker || sudo yum -y install docker
            sudo systemctl enable --now docker
          else
            sudo systemctl enable --now docker
          fi

          echo "$DOCKERHUB_PASSWORD" | sudo docker login -u "$DOCKERHUB_USERNAME" --password-stdin
          sudo docker pull "$IMAGE"
          sudo docker rm -f "$SVC" >/dev/null 2>&1 || true
          sudo docker run -d --name "$SVC" --restart unless-stopped -p "$PORT:$PORT" "$IMAGE"
          sudo docker image prune -af >/dev/null 2>&1 || true
          EOF
          done

