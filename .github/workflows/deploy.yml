name: CD Deploy (only changed services)

on:
  workflow_call:
    inputs:
      tag:
        required: true
        type: string
      env_alias:
        required: true
        type: string
      services:
        required: true
        type: string

concurrency:
  group: cd-${{ inputs.env_alias }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set TF backend/vars from env_alias
        run: |
          echo "TAG=${{ inputs.tag }}" >> $GITHUB_ENV
          echo "ENV_ALIAS=${{ inputs.env_alias }}" >> $GITHUB_ENV
          echo "SERVICES=${{ inputs.services }}" >> $GITHUB_ENV

          if [ "${{ inputs.env_alias }}" = "prod" ]; then
            echo "TF_BACKEND=backend-prod.hcl" >> $GITHUB_ENV
            echo "TFVARS=prod.tfvars" >> $GITHUB_ENV
          else
            echo "TF_BACKEND=backend-qa.hcl" >> $GITHUB_ENV
            echo "TFVARS=qa.tfvars" >> $GITHUB_ENV
          fi

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Configure AWS creds (bastion account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_BASTION_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_BASTION_SECRET_ACCESS_KEY }}
          aws-session-token:     ${{ secrets.AWS_BASTION_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Terraform init (read outputs)
        run: terraform -chdir=infra/terraform init -reconfigure -backend-config=$TF_BACKEND

      - name: Get bastion public ip
        id: bastion
        run: |
          echo "HOST=$(terraform -chdir=infra/terraform output -raw bastion_public_ip)" >> $GITHUB_OUTPUT

      - name: Prepare SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY_QA }}" | tr -d '\r' > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
      - name: Show SSH key fingerprint used by runner
        run: |
          echo "=== Runner key fingerprint (from SSH_PRIVATE_KEY_QA) ==="
          ssh-keygen -y -f ~/.ssh/id_rsa > /tmp/runner.pub
          ssh-keygen -lf /tmp/runner.pub
    

      - name: Push public key to bastion (EC2 Instance Connect)
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=*bastion*" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" --output text)

          AZ=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query "Reservations[0].Instances[0].Placement.AvailabilityZone" --output text)

          aws ec2-instance-connect send-ssh-public-key \
            --instance-id "$INSTANCE_ID" \
            --availability-zone "$AZ" \
            --instance-os-user ec2-user \
            --ssh-public-key "${{ secrets.SSH_PUBLIC_KEY_QA }}"

      - name: Test SSH to bastion
        env:
          BASTION_HOST: ${{ steps.bastion.outputs.HOST }}
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa -o IdentitiesOnly=yes ec2-user@"$BASTION_HOST" "whoami && hostname"




      - name: Verify key_name in Terraform state (user-service)
        run: |
          terraform -chdir=infra/terraform init -reconfigure -backend-config=$TF_BACKEND
          echo "=== key_name in state for ms_user_service ==="
          terraform -chdir=infra/terraform state show module.ms_user_service.aws_instance.microservice[0] | sed -n '1,120p' | grep -E "key_name|ami|subnet_id|private_ip|tags"

      - name: Push public key to target instances (EC2 Instance Connect)
        env:
          BASTION_HOST: ${{ steps.bastion.outputs.HOST }}
        run: |
          set -e
          ENDPOINTS_JSON=$(terraform -chdir=infra/terraform output -json service_endpoints)

          for SVC in $SERVICES; do
            IP=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d.get('$SVC', {}).get('ip'))")
            echo "Service=$SVC IP=$IP"

            SVC_TF=$(echo "$SVC" | tr '-' '_')
            ADDR="module.ms_${SVC_TF}.aws_instance.microservice[0]"

            terraform -chdir=infra/terraform state show -no-color "$ADDR" >/dev/null 2>&1 || { 
              echo "ERROR: $ADDR not found in terraform state"; 
              exit 1; 
            }

            INSTANCE_ID=$(terraform -chdir=infra/terraform state show -no-color "$ADDR" | awk -F' = ' '/^[[:space:]]*id[[:space:]]*=/{gsub(/"/,"",$2); print $2; exit}')
            AZ=$(terraform -chdir=infra/terraform state show -no-color "$ADDR" | awk -F' = ' '/^[[:space:]]*availability_zone[[:space:]]*=/{gsub(/"/,"",$2); print $2; exit}')

            echo "Pushing SSH key to $SVC ($IP) -> $INSTANCE_ID in $AZ"

            aws ec2-instance-connect send-ssh-public-key \
              --instance-id "$INSTANCE_ID" \
              --availability-zone "$AZ" \
              --instance-os-user ec2-user \
              --ssh-public-key "${{ secrets.SSH_PUBLIC_KEY_QA }}"
          done

      

      - name: Deploy changed services 
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_PASSWORD: ${{ secrets.DOCKERHUB_PASSWORD }}
          BASTION_HOST: ${{ steps.bastion.outputs.HOST }}
        run: |
          ENDPOINTS_JSON=$(terraform -chdir=infra/terraform output -json service_endpoints)

          
          TARGET_USER="ec2-user"

          for SVC in $SERVICES; do
            IP=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['$SVC']['ip'])")
            PORT=$(echo "$ENDPOINTS_JSON" | python3 -c "import sys,json; d=json.load(sys.stdin); print(d['$SVC']['port'])")

            IMAGE="${DOCKERHUB_USERNAME}/${SVC}:${TAG}"

            ssh -i ~/.ssh/id_rsa -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
              -J ec2-user@"$BASTION_HOST" "$TARGET_USER@$IP" <<EOF
          set -e
          if ! command -v docker >/dev/null 2>&1; then
            sudo yum -y update || true
            sudo amazon-linux-extras install -y docker || sudo yum -y install docker
            sudo systemctl enable --now docker
          else
            sudo systemctl enable --now docker
          fi

          echo "$DOCKERHUB_PASSWORD" | sudo docker login -u "$DOCKERHUB_USERNAME" --password-stdin
          sudo docker pull "$IMAGE"
          sudo docker rm -f "$SVC" >/dev/null 2>&1 || true
          sudo docker run -d --name "$SVC" --restart unless-stopped -p "$PORT:$PORT" "$IMAGE"
          sudo docker image prune -af >/dev/null 2>&1 || true
          EOF
          done

